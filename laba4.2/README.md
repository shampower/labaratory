# Задание

Замыкание для получения простых чисел.
Декоратор, не позволяющий функции выполняться больше определённого времени.

## Описание 
Составила словарь словарей и нашла расстояние между ними
используя цикл и функцию нахождения расстояния.

## Решение

Пояснение вывода:
Перестановки:

Для списка [1, 2, 3] и k=2 выводятся все возможные пары

Обе реализации (рекурсивная и итеративная) дают одинаковый результат

Последовательность:

Для n=5 вычисляется значение по модифицированной формуле

Результаты рекурсивного и итеративного вычислений совпадают

Простые числа:

Корректно определяются простые числа до 20

Ограничение времени:

При попытке вычислить перестановки для n=12 и k=10

Срабатывает декоратор time_limit и выводится сообщение об ошибке

Примечание: Точное значение последовательности для n=5 может незначительно отличаться в зависимости от реализации математических операций с плавающей точкой. Время срабатывания таймаута также может немного варьироваться в зависимости от скорости процессора.

## Скриншот
![image](https://github.com/user-attachments/assets/96b6aa99-e571-45d4-a290-ad4db7ea3388)

# Справочные материалы

## 1. Декоратор time_limit
Назначение:
Ограничивает время выполнения функции. Если выполнение превышает заданный лимит, вызывает исключение TimeoutError.

Код с пояснениями:

    import time
    import functools

    def time_limit(seconds):  # Функция-декоратор, принимающая лимит времени
        def decorator(func):  # Внутренняя функция, принимающая декорируемую функцию
            @functools.wraps(func)  # Сохраняет метаданные оригинальной функции
            def wrapper(*args, **kwargs):  # Обёртка, которая будет вызвана вместо func
                start_time = time.time()  # Засекаем время начала
                result = func(*args, **kwargs)  # Вызываем оригинальную функцию
                elapsed = time.time() - start_time  # Вычисляем время выполнения
            
            if elapsed > seconds:  # Проверяем, не превышен ли лимит
                raise TimeoutError(f"Функция {func.__name__} выполнялась {elapsed:.2f} сек (лимит: {seconds} сек)")
            return result  # Возвращаем результат, если уложились во время
        return wrapper  # Возвращаем обёрнутую функцию
    return decorator  # Возвращаем декоратор
Как работает:
time_limit(seconds) создает декоратор, который можно применить к любой функции.

При вызове декорированной функции:

Засекается время начала.

Выполняется оригинальная функция.

Если время выполнения превышает seconds, вызывается исключение.

## 2. Замыкание make_prime_checker
Назначение:
Создает функцию is_prime, которая проверяет, является ли число простым, с кэшированием уже найденных простых чисел.


    def make_prime_checker():  # Функция, создающая замыкание
        primes_cache = [2, 3]  # Кэш для хранения найденных простых чисел
    
        def is_prime(n):  # Функция, которая будет возвращена
            if n <= 1:  # Числа <= 1 не простые
                return False
            if n in primes_cache:  # Если число уже в кэше, оно простое
                return True
            if any(n % p == 0 for p in primes_cache):  # Проверка на делимость
                return False
            
            max_divisor = int(sqrt(n)) + 1  # Верхняя граница для проверки делителей
            for i in range(primes_cache[-1] + 2, max_divisor, 2):  # Проверяем только нечётные
                if is_prime(i) and n % i == 0:  # Рекурсивная проверка
                    return False
            
            primes_cache.append(n)  # Добавляем число в кэш, если оно простое
            return True
        
        return is_prime  # Возвращаем функцию is_prime
Как работает:
При вызове make_prime_checker() создается локальная переменная primes_cache и возвращается функция is_prime.

is_prime проверяет число n:

Использует кэш для ускорения проверки.

Проверяет делители только до √n (оптимизация).

Добавляет новые простые числа в кэш.

## 3. Функции для перестановок
Рекурсивная версия k_permutations_recursive

    @time_limit(1)  # Ограничение времени выполнения (1 сек)
    def k_permutations_recursive(elements, k):
        if k == 0:  # Базовый случай: перестановка длины 0 — пустой список
            return [[]]
        
        result = []  # Сюда будем собирать результаты
        for i in range(len(elements)):  # Перебираем все элементы
            current = elements[i]  # Текущий элемент
            remaining = elements[:i] + elements[i+1:]  # Оставшиеся элементы
            for p in k_permutations_recursive(remaining, k-1):  # Рекурсивный вызов
                result.append([current] + p)  # Добавляем комбинацию
        
        return result
Итеративная версия k_permutations_iterative

    @time_limit(1)
    def k_permutations_iterative(elements, k):
        result = []  # Результат
        n = len(elements)
        indices = list(range(n))  # Индексы элементов
        cycles = list(range(n, n-k, -1))  # Счётчики для перестановок
        
        result.append([elements[i] for i in indices[:k]])  # Первая перестановка
        
        while True:
            for i in reversed(range(k)):  # Идём с конца
                cycles[i] -= 1  # Уменьшаем счётчик
                if cycles[i] == 0:  # Если счётчик дошёл до 0
                    indices[i:] = indices[i+1:] + indices[i:i+1]  # Сдвигаем индексы
                    cycles[i] = n - i  # Сброс счётчика
                else:
                    j = cycles[i]  # Берём значение счётчика
                    indices[i], indices[-j] = indices[-j], indices[i]  # Меняем местами
                    result.append([elements[i] for i in indices[:k]])  # Добавляем перестановку
                    break  # Прерываем цикл for
            else:
                return result  # Если for завершился без break, возвращаем результат
Разница между версиями:
Рекурсивная	Итеративная
Проще для понимания	Сложнее, но нет риска переполнения стека
Может быть медленнее	Обычно быстрее
Использует больше памяти	Эффективнее по памяти
## 4. Функции для последовательности
Рекурсивная версия sequence_recursive

    @time_limit(1)
    def sequence_recursive(i):
        if i == 0:  # Базовый случай: x₀ = 0
            return 0
        prev = sequence_recursive(i-1)  # Рекурсивно вычисляем x_{i-1}
        term = 1/i if is_prime(i) else 1/(i**2)  # Выбираем формулу для term
        return i * prev + term  # Вычисляем x_i
Итеративная версия sequence_iterative

    @time_limit(1)
    def sequence_iterative(i):
        if i == 0:
            return 0
        x = 0  # Начальное значение x₀
        for n in range(1, i+1):  # Итеративно вычисляем до x_i
            term = 1/n if is_prime(n) else 1/(n**2)  # Аналогично рекурсивной версии
            x = n * x + term  # Вычисляем следующее значение
        return x
  
если i=0
если i простое
иначе
​
 
## 5. Примеры использования
Тест перестановок
python
elements = [1, 2, 3]
k = 2
print(k_permutations_recursive(elements, k))  # [[1,2], [1,3], [2,1], [2,3], [3,1], [3,2]]
Тест последовательности

    n = 5
    print(sequence_recursive(n))  # 5.717857142857142
Тест простых чисел

    print([x for x in range(20) if is_prime(x)])  # [2, 3, 5, 7, 11, 13, 17, 19]
Тест времени

    try:
        k_permutations_recursive(list(range(12)), 10)  # Вызовет TimeoutError
    except TimeoutError as e:
        print(e)  # "Функция... выполнялась слишком долго"

Этот код демонстрирует:

Декораторы для контроля времени выполнения.

Замыкания для кэширования простых чисел.

Рекурсию и итерацию для генерации перестановок.

Модифицированную последовательность, зависящую от простоты чисел.

Каждая функция имеет чёткое назначение и работает изолированно, без глобальных переменных.
